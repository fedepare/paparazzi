diff --git a/conf/firmwares/subsystems/fixedwing/autopilot.makefile b/conf/firmwares/subsystems/fixedwing/autopilot.makefile
index 5d196f1..1d38a5d 100644
--- a/conf/firmwares/subsystems/fixedwing/autopilot.makefile
+++ b/conf/firmwares/subsystems/fixedwing/autopilot.makefile
@@ -47,8 +47,6 @@ else
   $(TARGET).CFLAGS 	+= -DWIND_INFO
 endif
 
-$(TARGET).CFLAGS 	+= -DTRAFFIC_INFO
-
 #
 # frequencies
 #
diff --git a/conf/firmwares/subsystems/fixedwing/navigation.makefile b/conf/firmwares/subsystems/fixedwing/navigation.makefile
index 223c780..baa5a6d 100644
--- a/conf/firmwares/subsystems/fixedwing/navigation.makefile
+++ b/conf/firmwares/subsystems/fixedwing/navigation.makefile
@@ -7,8 +7,6 @@
 
 $(TARGET).CFLAGS += -DNAV
 $(TARGET).srcs += $(SRC_FIRMWARE)/nav.c
+#$(TARGET).srcs += subsystems/navigation/common_nav.c
 $(TARGET).srcs += $(SRC_SUBSYSTEMS)/navigation/common_flight_plan.c
-$(TARGET).srcs += $(SRC_SUBSYSTEMS)/navigation/traffic_info.c
 $(TARGET).srcs += $(SRC_SUBSYSTEMS)/navigation/nav_survey_rectangle.c
-
-
diff --git a/conf/firmwares/subsystems/rotorcraft/navigation.makefile b/conf/firmwares/subsystems/rotorcraft/navigation.makefile
index 96e64ca..da81cc8 100644
--- a/conf/firmwares/subsystems/rotorcraft/navigation.makefile
+++ b/conf/firmwares/subsystems/rotorcraft/navigation.makefile
@@ -2,6 +2,6 @@
 
 $(TARGET).CFLAGS += -DUSE_NAVIGATION
 $(TARGET).srcs += $(SRC_FIRMWARE)/navigation.c
+#$(TARGET).srcs += subsystems/navigation/common_nav.c
 $(TARGET).srcs += subsystems/navigation/waypoints.c
 $(TARGET).srcs += subsystems/navigation/common_flight_plan.c
-$(TARGET).srcs += subsystems/navigation/traffic_info.c
diff --git a/conf/modules/follow.xml b/conf/modules/follow.xml
index 82ad5bc..d413fb4 100644
--- a/conf/modules/follow.xml
+++ b/conf/modules/follow.xml
@@ -3,7 +3,7 @@
 <module name="follow" dir="multi">
   <doc>
     <description>
-      Follow a certain AC_ID trough remote GPS.
+      Follow a certain AC_ID through remote GPS.
       Only for rotorcraft firmware.
     </description>
     <define name="FOLLOW_AC_ID"               description="the aircraft ID which it has to follow"/>
@@ -13,12 +13,14 @@
     <define name="FOLLOW_OFFSET_Z" value="0"  description="the z offset in ENU (meters) from the plane"/>
   </doc>
 
+  <depends>traffic_info</depends>
+
   <header>
     <file name="follow.h"/>
   </header>
 
   <init fun="follow_init()"/>
-  <datalink message="REMOTE_GPS" fun="ParseRemoteGps()"/>
+  <periodic fun="follow_wp()" freq="5" autorun="FALSE"/>
 
   <makefile>
     <file name="follow.c"/>
diff --git a/sw/airborne/arch/sim/sim_ap.c b/sw/airborne/arch/sim/sim_ap.c
index 64b71d9..a229d74 100644
--- a/sw/airborne/arch/sim/sim_ap.c
+++ b/sw/airborne/arch/sim/sim_ap.c
@@ -13,7 +13,6 @@
 #include "inter_mcu.h"
 #include "autopilot.h"
 #include "subsystems/gps.h"
-#include "subsystems/navigation/traffic_info.h"
 #include "generated/settings.h"
 #include "firmwares/fixedwing/nav.h"
 #include "firmwares/fixedwing/stabilization/stabilization_attitude.h"
diff --git a/sw/airborne/firmwares/fixedwing/main_ap.c b/sw/airborne/firmwares/fixedwing/main_ap.c
index 5bbbb64..450de8e 100644
--- a/sw/airborne/firmwares/fixedwing/main_ap.c
+++ b/sw/airborne/firmwares/fixedwing/main_ap.c
@@ -67,9 +67,6 @@ PRINT_CONFIG_MSG_VALUE("USE_BARO_BOARD is TRUE, reading onboard baro: ", BARO_BO
 #include CTRL_TYPE_H
 #include "firmwares/fixedwing/nav.h"
 #include "generated/flight_plan.h"
-#ifdef TRAFFIC_INFO
-#include "subsystems/navigation/traffic_info.h"
-#endif
 
 // datalink & telemetry
 #if DATALINK || SITL
@@ -255,12 +252,6 @@ void init_ap(void)
   IO0SET = _BV(AEROCOMM_DATA_PIN);
 #endif
 
-  /************ Multi-uavs status ***************/
-
-#ifdef TRAFFIC_INFO
-  traffic_info_init();
-#endif
-
   /* set initial trim values.
    * these are passed to fbw via inter_mcu.
    */
diff --git a/sw/airborne/firmwares/fixedwing/nav.c b/sw/airborne/firmwares/fixedwing/nav.c
index 243240e..dc8d11c 100644
--- a/sw/airborne/firmwares/fixedwing/nav.c
+++ b/sw/airborne/firmwares/fixedwing/nav.c
@@ -35,7 +35,6 @@ static unit_t unit __attribute__((unused));
 #include "firmwares/fixedwing/stabilization/stabilization_attitude.h"
 #include "firmwares/fixedwing/autopilot.h"
 #include "inter_mcu.h"
-#include "subsystems/navigation/traffic_info.h"
 #include "subsystems/gps.h"
 
 #include "generated/flight_plan.h"
@@ -284,17 +283,19 @@ static inline bool compute_TOD(uint8_t _af, uint8_t _td, uint8_t _tod, float gli
 #define LINE_STOP_FUNCTION {}
 #endif
 
+#ifdef TRAFFIC_INFO
+#include "modules/multi/traffic_info.h"
 
 
 void nav_follow(uint8_t _ac_id, float _distance, float _height)
 {
   struct ac_info_ * ac = get_ac_info(_ac_id);
   NavVerticalAutoThrottleMode(0.);
-  NavVerticalAltitudeMode(Max(ac->alt + _height, ground_alt + SECURITY_HEIGHT), 0.);
+  NavVerticalAltitudeMode(Max(ac->utm.alt + _height, ground_alt + SECURITY_HEIGHT), 0.);
   float alpha = M_PI / 2 - ac->course;
   float ca = cosf(alpha), sa = sinf(alpha);
-  float x = ac->east - _distance * ca;
-  float y = ac->north - _distance * sa;
+  float x = ac->utm.east/100. - _distance * ca;
+  float y = ac->utm.north/100. - _distance * sa;
   fly_to_xy(x, y);
 #ifdef NAV_FOLLOW_PGAIN
   float s = (stateGetPositionEnu_f()->x - x) * ca + (stateGetPositionEnu_f()->y - y) * sa;
@@ -302,6 +303,11 @@ void nav_follow(uint8_t _ac_id, float _distance, float _height)
   nav_ground_speed_loop();
 #endif
 }
+#else
+void nav_follow(uint8_t  __attribute__((unused)) _ac_id, float  __attribute__((unused)) distance, float  __attribute__((unused)) height){}
+#endif // TRAFFIC_INFO
+
+
 
 float nav_altitude = GROUND_ALT + MIN_HEIGHT_CARROT;
 float desired_x, desired_y;
diff --git a/sw/airborne/math/pprz_geodetic.h b/sw/airborne/math/pprz_geodetic.h
index a7c40b7..c9dacf8 100644
--- a/sw/airborne/math/pprz_geodetic.h
+++ b/sw/airborne/math/pprz_geodetic.h
@@ -70,31 +70,42 @@ extern "C" {
     (_u1).zone = (_u2).zone;     \
   }
 
-
-#define ENU_OF_UTM_DIFF(_pos, _utm1, _utm2) { \
+#define ENU_OF_UTM_DIFF(_pos, _utm1, _utm2) {   \
     (_pos).x = (_utm1).east - (_utm2).east;     \
     (_pos).y = (_utm1).north - (_utm2).north;   \
     (_pos).z = (_utm1).alt - (_utm2).alt;       \
   }
 
-#define NED_OF_UTM_DIFF(_pos, _utm1, _utm2) { \
+#define NED_OF_UTM_DIFF(_pos, _utm1, _utm2) {   \
     (_pos).x = (_utm1).north - (_utm2).north;   \
     (_pos).y = (_utm1).east - (_utm2).east;     \
     (_pos).z = -(_utm1).alt + (_utm2).alt;      \
   }
 
-#define UTM_OF_ENU_ADD(_utm, _pos, _utm0) { \
+#define UTM_OF_ENU_ADD(_utm, _pos, _utm0) {    \
     (_utm).east = (_utm0).east + (_pos).x;     \
     (_utm).north = (_utm0).north + (_pos).y;   \
     (_utm).alt = (_utm0).alt + (_pos).z;       \
   }
 
-#define UTM_OF_NED_ADD(_utm, _pos, _utm0) { \
+#define UTM_OF_NED_ADD(_utm, _pos, _utm0) {    \
     (_utm).east = (_utm0).east + (_pos).y;     \
     (_utm).north = (_utm0).north + (_pos).x;   \
     (_utm).alt = (_utm0).alt - (_pos).z;       \
   }
 
+#define ENU_SUM(_res, _pos1, _pos2) {  \
+    (_res).x = (_pos1).x + (_pos2).x;  \
+    (_res).y = (_pos1).y + (_pos2).y;  \
+    (_res).z = (_pos1).z + (_pos2).z;  \
+  }
+
+#define ENU_DIFF(_res, _pos1, _pos2) {  \
+    (_res).x = (_pos1).x - (_pos2).x;   \
+    (_res).y = (_pos1).y - (_pos2).y;   \
+    (_res).z = (_pos1).z - (_pos2).z;   \
+  }
+
 #ifdef __cplusplus
 } /* extern "C" */
 #endif
diff --git a/sw/airborne/modules/airborne_ant_track/airborne_ant_track.c b/sw/airborne/modules/airborne_ant_track/airborne_ant_track.c
index df89779..cdf977c 100644
--- a/sw/airborne/modules/airborne_ant_track/airborne_ant_track.c
+++ b/sw/airborne/modules/airborne_ant_track/airborne_ant_track.c
@@ -24,7 +24,6 @@
 #include "autopilot.h"
 #include "generated/flight_plan.h"
 #include "state.h"
-#include "subsystems/navigation/traffic_info.h"
 #include "airborne_ant_track.h"
 
 
@@ -116,8 +115,8 @@ void airborne_ant_point_periodic(void)
   /*
    * This is for one axis pan antenna mechanisms. The default is to
    * circle clockwise so view is right. The pan servo neutral makes
-   * the antenna look to the right with 0° given, 90° is to the back and
-   * -90° is to the front.
+   * the antenna look to the right with 0ï¿½ given, 90ï¿½ is to the back and
+   * -90ï¿½ is to the front.
    *
    *
    *
@@ -126,13 +125,13 @@ void airborne_ant_point_periodic(void)
    *                  90
                       ^
    *                  I
-   *             135  I  45°
+   *             135  I  45ï¿½
    *                \ I /
    *                 \I/
-   *        180-------I------- 0°
+   *        180-------I------- 0ï¿½
    *                 /I\
    *                / I \
-   *            -135  I  -45°
+   *            -135  I  -45ï¿½
    *                  I
    *                -90
    *             plane back
diff --git a/sw/airborne/modules/cam_control/cam.c b/sw/airborne/modules/cam_control/cam.c
index 768d47f..df98c44 100644
--- a/sw/airborne/modules/cam_control/cam.c
+++ b/sw/airborne/modules/cam_control/cam.c
@@ -30,7 +30,6 @@
 #include "autopilot.h"
 #include "generated/flight_plan.h"
 #include "state.h"
-#include "subsystems/navigation/traffic_info.h"
 #ifdef POINT_CAM
 #include "point.h"
 #endif // POINT_CAM
@@ -303,13 +302,17 @@ void cam_waypoint_target(void)
   cam_target();
 }
 
+#ifdef TRAFFIC_INFO
+#include "modules/multi/traffic_info.h"
+
 void cam_ac_target(void)
 {
-#ifdef TRAFFIC_INFO
   struct ac_info_ * ac = get_ac_info(cam_target_ac);
-  cam_target_x = ac->east;
-  cam_target_y = ac->north;
-  cam_target_alt = ac->alt;
+  cam_target_x = ac->utm.east/100.;
+  cam_target_y = ac->utm.north/100.;
+  cam_target_alt = ac->utm.alt/1000.;
   cam_target();
-#endif // TRAFFIC_INFO
 }
+#else 
+void cam_ac_target(void){}
+#endif // TRAFFIC_INFO
diff --git a/sw/airborne/modules/multi/follow.c b/sw/airborne/modules/multi/follow.c
index 9d35508..0cbc52c 100644
--- a/sw/airborne/modules/multi/follow.c
+++ b/sw/airborne/modules/multi/follow.c
@@ -32,8 +32,6 @@
 #include "subsystems/navigation/waypoints.h"
 
 #include "state.h"
-#include "pprzlink/messages.h"
-#include "pprzlink/dl_protocol.h"
 
 #ifndef FOLLOW_OFFSET_X
 #define FOLLOW_OFFSET_X 0.0
@@ -47,32 +45,44 @@
 #define FOLLOW_OFFSET_Z 0.0
 #endif
 
-void follow_init(void)
-{
+#ifndef FOLLOW_AC_ID
+#error "Please define FOLLOW_AC_ID"
+#endif
 
-}
+#ifndef FOLLOW_WAYPOINT_ID
+#error "Please define FOLLOW_WAYPOINT_ID"
+#endif
 
-void follow_change_wp(unsigned char *buffer)
+void follow_init(void){}
+
+/*
+ * follow_wp(void)
+ * updates the FOLLOW_WAYPOINT_ID to a fixed offset from the last received location
+ * of other aircraft with id FOLLOW_AC_ID
+ */
+void follow_wp(void)
 {
-  struct EcefCoor_i new_pos;
-  struct EnuCoor_i enu;
-  new_pos.x = DL_REMOTE_GPS_ecef_x(buffer);
-  new_pos.y = DL_REMOTE_GPS_ecef_y(buffer);
-  new_pos.z = DL_REMOTE_GPS_ecef_z(buffer);
+  struct ac_info_ * ac = get_ac_info(FOLLOW_AC_ID);
+
+  // todo replace with stateGet function when they are working for utm pos
+  struct UtmCoor_f my_pos = utm_float_from_gps(&gps, 0);
+  my_pos.alt = gps.hmsl / 1000.;
 
-  // Translate to ENU
-  enu_of_ecef_point_i(&enu, &state.ned_origin_i, &new_pos);
-  INT32_VECT3_SCALE_2(enu, enu, INT32_POS_OF_CM_NUM, INT32_POS_OF_CM_DEN);
+  // get the distance to the other vehicle to be followed
+  struct EnuCoor_f enu = stateGetPositionEnu_f();
+  enu.x += ac->utm.east/100. - my_pos.east;
+  enu.y += ac->utm.north/100. - my_pos.north;
+  enu.z += ac->utm.alt/1000. - my_pos.alt;
 
   // TODO: Add the angle to the north
 
   // Update the offsets
-  enu.x += POS_BFP_OF_REAL(FOLLOW_OFFSET_X);
-  enu.y += POS_BFP_OF_REAL(FOLLOW_OFFSET_Y);
-  enu.z += POS_BFP_OF_REAL(FOLLOW_OFFSET_Z);
+  enu.x += FOLLOW_OFFSET_X;
+  enu.y += FOLLOW_OFFSET_Y;
+  enu.z += FOLLOW_OFFSET_Z;
 
   // TODO: Remove the angle to the north
 
   // Move the waypoint
-  waypoint_set_enu_i(FOLLOW_WAYPOINT_ID, &enu);
+  waypoint_set_enu(FOLLOW_WAYPOINT_ID, &enu);
 }
diff --git a/sw/airborne/modules/multi/follow.h b/sw/airborne/modules/multi/follow.h
index 01608d0..2cba086 100644
--- a/sw/airborne/modules/multi/follow.h
+++ b/sw/airborne/modules/multi/follow.h
@@ -28,12 +28,6 @@
 #define FOLLOW_H
 
 extern void follow_init(void);
-extern void follow_change_wp(unsigned char *buffer);
-
-#define ParseRemoteGps() { \
-    if (DL_REMOTE_GPS_ac_id(dl_buffer) == FOLLOW_AC_ID) { \
-      follow_change_wp(dl_buffer); \
-    } \
-  }
+extern void follow_wp(void);
 
 #endif // FOLLOW
diff --git a/sw/airborne/modules/multi/formation.c b/sw/airborne/modules/multi/formation.c
index 8f74828..8f9d22a 100644
--- a/sw/airborne/modules/multi/formation.c
+++ b/sw/airborne/modules/multi/formation.c
@@ -83,12 +83,12 @@ int formation_init(void)
 
 int add_slot(uint8_t _id, float slot_e, float slot_n, float slot_a)
 {
-  if (_id != AC_ID && the_acs_id[_id] == 0) { return false; } // no info for this AC
+  if (_id != AC_ID && ti_acs_id[_id] == 0) { return false; } // no info for this AC
   DOWNLINK_SEND_FORMATION_SLOT_TM(DefaultChannel, DefaultDevice, &_id, &form_mode, &slot_e, &slot_n, &slot_a);
-  formation[the_acs_id[_id]].status = IDLE;
-  formation[the_acs_id[_id]].east = slot_e;
-  formation[the_acs_id[_id]].north = slot_n;
-  formation[the_acs_id[_id]].alt = slot_a;
+  formation[ti_acs_id[_id]].status = IDLE;
+  formation[ti_acs_id[_id]].east = slot_e;
+  formation[ti_acs_id[_id]].north = slot_n;
+  formation[ti_acs_id[_id]].alt = slot_a;
   return false;
 }
 
@@ -141,8 +141,8 @@ int formation_flight(void)
   form_speed_e = form_speed * sh;
 
   if (AC_ID == leader_id) {
-    stateGetPositionEnu_f()->x += formation[the_acs_id[AC_ID]].east;
-    stateGetPositionEnu_f()->y += formation[the_acs_id[AC_ID]].north;
+    stateGetPositionEnu_f()->x += formation[ti_acs_id[AC_ID]].east;
+    stateGetPositionEnu_f()->y += formation[ti_acs_id[AC_ID]].north;
   }
   // set info for this AC
   set_ac_info(AC_ID, stateGetPositionEnu_f()->x, stateGetPositionEnu_f()->y, hspeed_dir,
@@ -150,21 +150,21 @@ int formation_flight(void)
 
   // broadcast info
   uint8_t ac_id = AC_ID;
-  uint8_t status = formation[the_acs_id[AC_ID]].status;
+  uint8_t status = formation[ti_acs_id[AC_ID]].status;
   DOWNLINK_SEND_FORMATION_STATUS_TM(DefaultChannel, DefaultDevice, &ac_id, &leader_id, &status);
   if (++_1Hz >= 4) {
     _1Hz = 0;
     DOWNLINK_SEND_FORMATION_SLOT_TM(DefaultChannel, DefaultDevice, &ac_id, &form_mode,
-                                    &formation[the_acs_id[AC_ID]].east,
-                                    &formation[the_acs_id[AC_ID]].north,
-                                    &formation[the_acs_id[AC_ID]].alt);
+                                    &formation[ti_acs_id[AC_ID]].east,
+                                    &formation[ti_acs_id[AC_ID]].north,
+                                    &formation[ti_acs_id[AC_ID]].alt);
   }
-  if (formation[the_acs_id[AC_ID]].status != ACTIVE) { return false; } // AC not ready
+  if (formation[ti_acs_id[AC_ID]].status != ACTIVE) { return false; } // AC not ready
 
   // get leader info
   struct ac_info_ * leader = get_ac_info(leader_id);
-  if (formation[the_acs_id[leader_id]].status == UNSET ||
-      formation[the_acs_id[leader_id]].status == IDLE) {
+  if (formation[ti_acs_id[leader_id]].status == UNSET ||
+      formation[ti_acs_id[leader_id]].status == IDLE) {
     // leader not ready or not in formation
     return false;
   }
@@ -185,8 +185,8 @@ int formation_flight(void)
 
   // compute control forces
   for (i = 0; i < NB_ACS; ++i) {
-    if (the_acs[i].ac_id == AC_ID) { continue; }
-    struct ac_info_ * ac = get_ac_info(the_acs[i].ac_id);
+    if (ti_acs[i].ac_id == AC_ID) { continue; }
+    struct ac_info_ * ac = get_ac_info(ti_acs[i].ac_id);
     float delta_t = Max((int)(gps.tow - ac->itow) / 1000., 0.);
     if (delta_t > FORM_CARROT) {
       // if AC not responding for too long
@@ -195,12 +195,12 @@ int formation_flight(void)
     } else {
       // compute control if AC is ACTIVE and around the same altitude (maybe not so usefull)
       formation[i].status = ACTIVE;
-      if (ac->alt > 0 && fabs(stateGetPositionUtm_f()->alt - ac->alt) < form_prox) {
-        form_e += (ac->east  + ac->gspeed * sinf(ac->course) * delta_t - stateGetPositionEnu_f()->x)
-          - (form[i].east - form[the_acs_id[AC_ID]].east);
-        form_n += (ac->north + ac->gspeed * cosf(ac->course) * delta_t - stateGetPositionEnu_f()->y)
-          - (form[i].north - form[the_acs_id[AC_ID]].north);
-        form_a += (ac->alt - stateGetPositionUtm_f()->alt) - (formation[i].alt - formation[the_acs_id[AC_ID]].alt);
+      if (ac->utm.alt> 0 && fabs(stateGetPositionUtm_f()->alt - ac->utm.alt) < form_prox) {
+        form_e += (ac->utm.east/100.  + ac->gspeed * sinf(ac->course) * delta_t - stateGetPositionEnu_f()->x)
+          - (form[i].east - form[ti_acs_id[AC_ID]].east);
+        form_n += (ac->utm.north/100. + ac->gspeed * cosf(ac->course) * delta_t - stateGetPositionEnu_f()->y)
+          - (form[i].north - form[ti_acs_id[AC_ID]].north);
+        form_a += (ac->utm.alt/1000. - stateGetPositionUtm_f()->alt) - (formation[i].alt - formation[ti_acs_id[AC_ID]].alt);
         form_speed += ac->gspeed;
         //form_speed_e += ac->gspeed * sinf(ac->course);
         //form_speed_n += ac->gspeed * cosf(ac->course);
@@ -224,21 +224,21 @@ int formation_flight(void)
   if (AC_ID == leader_id) {
     alt = nav_altitude;
   } else {
-    alt = leader->alt - form[the_acs_id[leader_id]].alt;
+    alt = leader->utm.alt/1000. - form[ti_acs_id[leader_id]].alt;
   }
-  alt += formation[the_acs_id[AC_ID]].alt + coef_form_alt * form_a;
+  alt += formation[ti_acs_id[AC_ID]].alt + coef_form_alt * form_a;
   flight_altitude = Max(alt, ground_alt + SECURITY_HEIGHT);
 
   // carrot
   if (AC_ID != leader_id) {
-    float dx = form[the_acs_id[AC_ID]].east - form[the_acs_id[leader_id]].east;
-    float dy = form[the_acs_id[AC_ID]].north - form[the_acs_id[leader_id]].north;
-    desired_x = leader->east  + NOMINAL_AIRSPEED * form_carrot * sinf(leader->course) + dx;
-    desired_y = leader->north + NOMINAL_AIRSPEED * form_carrot * cosf(leader->course) + dy;
+    float dx = form[ti_acs_id[AC_ID]].east - form[ti_acs_id[leader_id]].east;
+    float dy = form[ti_acs_id[AC_ID]].north - form[ti_acs_id[leader_id]].north;
+    desired_x = leader->utm.east/100.  + NOMINAL_AIRSPEED * form_carrot * sinf(leader->course) + dx;
+    desired_y = leader->utm.north/100. + NOMINAL_AIRSPEED * form_carrot * cosf(leader->course) + dy;
     // fly to desired
     fly_to_xy(desired_x, desired_y);
-    desired_x = leader->east  + dx;
-    desired_y = leader->north + dy;
+    desired_x = leader->utm.east/100.  + dx;
+    desired_y = leader->utm.north/100. + dy;
     // lateral correction
     //float diff_heading = asin((dx*ch - dy*sh) / sqrt(dx*dx + dy*dy));
     //float diff_course = leader->course - hspeed_dir;
@@ -261,8 +261,8 @@ int formation_flight(void)
 void formation_pre_call(void)
 {
   if (leader_id == AC_ID) {
-    stateGetPositionEnu_f()->x -= formation[the_acs_id[AC_ID]].east;
-    stateGetPositionEnu_f()->y -= formation[the_acs_id[AC_ID]].north;
+    stateGetPositionEnu_f()->x -= formation[ti_acs_id[AC_ID]].east;
+    stateGetPositionEnu_f()->y -= formation[ti_acs_id[AC_ID]].north;
   }
 }
 
diff --git a/sw/airborne/modules/multi/formation.h b/sw/airborne/modules/multi/formation.h
index 2ee993a..1f85fcb 100644
--- a/sw/airborne/modules/multi/formation.h
+++ b/sw/airborne/modules/multi/formation.h
@@ -8,7 +8,7 @@
 #define FORMATION_H
 
 #include "firmwares/fixedwing/nav.h"
-#include "subsystems/navigation/traffic_info.h"
+#include "modules/multi/traffic_info.h"
 
 #define FORM_MODE_GLOBAL 0
 #define FORM_MODE_COURSE 1
@@ -34,12 +34,12 @@ extern int formation_init(void);
 extern int add_slot(uint8_t _id, float slot_e, float slot_n, float slot_a);
 
 #define UpdateSlot(_id, _se, _sn, _sa) { \
-    formation[the_acs_id[_id]].east = _se; \
-    formation[the_acs_id[_id]].north = _sn; \
-    formation[the_acs_id[_id]].alt = _sa; \
+    formation[ti_acs_id[_id]].east = _se; \
+    formation[ti_acs_id[_id]].north = _sn; \
+    formation[ti_acs_id[_id]].alt = _sa; \
   }
 
-#define UpdateFormationStatus(_id,_status) { formation[the_acs_id[_id]].status = _status; }
+#define UpdateFormationStatus(_id,_status) { formation[ti_acs_id[_id]].status = _status; }
 
 #define ParseFormationStatus() { \
     uint8_t ac_id = DL_FORMATION_STATUS_ac_id(dl_buffer); \
diff --git a/sw/airborne/modules/multi/potential.c b/sw/airborne/modules/multi/potential.c
index 849c4b3..1db280a 100644
--- a/sw/airborne/modules/multi/potential.c
+++ b/sw/airborne/modules/multi/potential.c
@@ -67,25 +67,25 @@ int potential_task(void)
   // compute control forces
   int8_t nb = 0;
   for (i = 0; i < NB_ACS; ++i) {
-    if (the_acs[i].ac_id == AC_ID) { continue; }
-    struct ac_info_ * ac = get_ac_info(the_acs[i].ac_id);
+    if (ti_acs[i].ac_id == AC_ID) { continue; }
+    struct ac_info_ * ac = get_ac_info(ti_acs[i].ac_id);
     float delta_t = Max((int)(gps.tow - ac->itow) / 1000., 0.);
     // if AC not responding for too long, continue, else compute force
     if (delta_t > CARROT) { continue; }
     else {
       float sha = sinf(ac->course);
       float cha = cosf(ac->course);
-      float de = ac->east  + sha * delta_t - stateGetPositionEnu_f()->x;
+      float de = ac->utm.east/100.  + sha * delta_t - stateGetPositionEnu_f()->x;
       if (de > FORCE_MAX_DIST || de < -FORCE_MAX_DIST) { continue; }
-      float dn = ac->north + cha * delta_t - stateGetPositionEnu_f()->y;
+      float dn = ac->utm.north/100. + cha * delta_t - stateGetPositionEnu_f()->y;
       if (dn > FORCE_MAX_DIST || dn < -FORCE_MAX_DIST) { continue; }
-      float da = ac->alt + ac->climb * delta_t - stateGetPositionUtm_f()->alt;
+      float da = ac->utm.alt/1000. + ac->climb * delta_t - stateGetPositionUtm_f()->alt;
       if (da > FORCE_MAX_DIST || da < -FORCE_MAX_DIST) { continue; }
       float dist = sqrtf(de * de + dn * dn + da * da);
       if (dist == 0.) { continue; }
       float dve = stateGetHorizontalSpeedNorm_f() * sh - ac->gspeed * sha;
       float dvn = stateGetHorizontalSpeedNorm_f() * ch - ac->gspeed * cha;
-      float dva = stateGetSpeedEnu_f()->z - the_acs[i].climb;
+      float dva = stateGetSpeedEnu_f()->z - ti_acs[i].climb;
       float scal = dve * de + dvn * dn + dva * da;
       if (scal < 0.) { continue; } // No risk of collision
       float d3 = dist * dist * dist;
diff --git a/sw/airborne/modules/multi/potential.h b/sw/airborne/modules/multi/potential.h
index 4cff965..4ce2861 100644
--- a/sw/airborne/modules/multi/potential.h
+++ b/sw/airborne/modules/multi/potential.h
@@ -8,7 +8,7 @@
 #define POTENTIAL_H
 
 #include "firmwares/fixedwing/nav.h"
-#include "subsystems/navigation/traffic_info.h"
+#include "modules/multi/traffic_info.h"
 
 struct force_ {
   float east;
diff --git a/sw/airborne/modules/multi/tcas.c b/sw/airborne/modules/multi/tcas.c
index 99945b1..a2dbdfc 100644
--- a/sw/airborne/modules/multi/tcas.c
+++ b/sw/airborne/modules/multi/tcas.c
@@ -88,7 +88,7 @@ void tcas_init(void)
 static inline enum tcas_resolve tcas_test_direction(uint8_t id)
 {
   struct ac_info_ * ac = get_ac_info(id);
-  float dz = ac->alt - stateGetPositionUtm_f()->alt;
+  float dz = ac->utm.alt/1000. - stateGetPositionUtm_f()->alt;
   if (dz > tcas_alim / 2) { return RA_DESCEND; }
   else if (dz < -tcas_alim / 2) { return RA_CLIMB; }
   else { // AC with the smallest ID descend
@@ -114,19 +114,19 @@ void tcas_periodic_task_1Hz(void)
   float vx = stateGetHorizontalSpeedNorm_f() * sinf(stateGetHorizontalSpeedDir_f());
   float vy = stateGetHorizontalSpeedNorm_f() * cosf(stateGetHorizontalSpeedDir_f());
   for (i = 2; i < NB_ACS; i++) {
-    if (the_acs[i].ac_id == 0) { continue; } // no AC data
-    uint32_t dt = gps.tow - the_acs[i].itow;
+    if (ti_acs[i].ac_id == 0) { continue; } // no AC data
+    uint32_t dt = gps.tow - ti_acs[i].itow;
     if (dt > 3 * TCAS_DT_MAX) {
       tcas_acs_status[i].status = TCAS_NO_ALARM; // timeout, reset status
       continue;
     }
     if (dt > TCAS_DT_MAX) { continue; } // lost com but keep current status
-    float dx = the_acs[i].east - stateGetPositionEnu_f()->x;
-    float dy = the_acs[i].north - stateGetPositionEnu_f()->y;
-    float dz = the_acs[i].alt - stateGetPositionUtm_f()->alt;
-    float dvx = vx - the_acs[i].gspeed * sinf(the_acs[i].course);
-    float dvy = vy - the_acs[i].gspeed * cosf(the_acs[i].course);
-    float dvz = stateGetSpeedEnu_f()->z - the_acs[i].climb;
+    float dx = ti_acs[i]->utm.east/100. - stateGetPositionEnu_f()->x;
+    float dy = ti_acs[i]->utm.north/100. - stateGetPositionEnu_f()->y;
+    float dz = ti_acs[i]->utm.alt/1000 - stateGetPositionUtm_f()->alt;
+    float dvx = vx - ti_acs[i].gspeed * sinf(ti_acs[i].course);
+    float dvy = vy - ti_acs[i].gspeed * cosf(ti_acs[i].course);
+    float dvz = stateGetSpeedEnu_f()->z - ti_acs[i].climb;
     float scal = dvx * dx + dvy * dy + dvz * dz;
     float ddh = dx * dx + dy * dy;
     float ddv = dz * dz;
@@ -140,60 +140,60 @@ void tcas_periodic_task_1Hz(void)
         if (tau >= TCAS_HUGE_TAU && !inside) {
           tcas_acs_status[i].status = TCAS_NO_ALARM; // conflict is now resolved
           tcas_acs_status[i].resolve = RA_NONE;
-          DOWNLINK_SEND_TCAS_RESOLVED(DefaultChannel, DefaultDevice, &(the_acs[i].ac_id));
+          DOWNLINK_SEND_TCAS_RESOLVED(DefaultChannel, DefaultDevice, &(ti_acs[i].ac_id));
         }
         break;
       case TCAS_TA:
         if (tau < tcas_tau_ra || inside) {
           tcas_acs_status[i].status = TCAS_RA; // TA -> RA
           // Downlink alert
-          //test_dir = tcas_test_direction(the_acs[i].ac_id);
-          //DOWNLINK_SEND_TCAS_RA(DefaultChannel, DefaultDevice,&(the_acs[i].ac_id),&test_dir);// FIXME only one closest AC ???
+          //test_dir = tcas_test_direction(ti_acs[i].ac_id);
+          //DOWNLINK_SEND_TCAS_RA(DefaultChannel, DefaultDevice,&(ti_acs[i].ac_id),&test_dir);// FIXME only one closest AC ???
           break;
         }
         if (tau > tcas_tau_ta && !inside) {
           tcas_acs_status[i].status = TCAS_NO_ALARM;  // conflict is now resolved
         }
         tcas_acs_status[i].resolve = RA_NONE;
-        DOWNLINK_SEND_TCAS_RESOLVED(DefaultChannel, DefaultDevice, &(the_acs[i].ac_id));
+        DOWNLINK_SEND_TCAS_RESOLVED(DefaultChannel, DefaultDevice, &(ti_acs[i].ac_id));
         break;
       case TCAS_NO_ALARM:
         if (tau < tcas_tau_ta || inside) {
           tcas_acs_status[i].status = TCAS_TA; // NO_ALARM -> TA
           // Downlink warning
-          DOWNLINK_SEND_TCAS_TA(DefaultChannel, DefaultDevice, &(the_acs[i].ac_id));
+          DOWNLINK_SEND_TCAS_TA(DefaultChannel, DefaultDevice, &(ti_acs[i].ac_id));
         }
         if (tau < tcas_tau_ra || inside) {
           tcas_acs_status[i].status = TCAS_RA; // NO_ALARM -> RA = big problem ?
           // Downlink alert
-          //test_dir = tcas_test_direction(the_acs[i].ac_id);
-          //DOWNLINK_SEND_TCAS_RA(DefaultChannel, DefaultDevice,&(the_acs[i].ac_id),&test_dir);
+          //test_dir = tcas_test_direction(ti_acs[i].ac_id);
+          //DOWNLINK_SEND_TCAS_RA(DefaultChannel, DefaultDevice,&(ti_acs[i].ac_id),&test_dir);
         }
         break;
     }
     // store closest AC
     if (tau < tau_min) {
       tau_min = tau;
-      ac_id_close = the_acs[i].ac_id;
+      ac_id_close = ti_acs[i].ac_id;
 
     }
   }
   // set current conflict mode
-  if (tcas_status == TCAS_RA && tcas_ac_RA != AC_ID && tcas_acs_status[the_acs_id[tcas_ac_RA]].status == TCAS_RA) {
+  if (tcas_status == TCAS_RA && tcas_ac_RA != AC_ID && tcas_acs_status[ti_acs_id[tcas_ac_RA]].status == TCAS_RA) {
     ac_id_close = tcas_ac_RA; // keep RA until resolved
   }
-  tcas_status = tcas_acs_status[the_acs_id[ac_id_close]].status;
+  tcas_status = tcas_acs_status[ti_acs_id[ac_id_close]].status;
   // at least one in conflict, deal with closest one
   if (tcas_status == TCAS_RA) {
     tcas_ac_RA = ac_id_close;
     tcas_resolve = tcas_test_direction(tcas_ac_RA);
-    uint8_t ac_resolve = tcas_acs_status[the_acs_id[tcas_ac_RA]].resolve;
+    uint8_t ac_resolve = tcas_acs_status[ti_acs_id[tcas_ac_RA]].resolve;
     if (ac_resolve != RA_NONE) { // first resolution, no message received
       if (ac_resolve == tcas_resolve) { // same direction, lowest id go down
         if (AC_ID < tcas_ac_RA) { tcas_resolve = RA_DESCEND; }
         else { tcas_resolve = RA_CLIMB; }
       }
-      tcas_acs_status[the_acs_id[tcas_ac_RA]].resolve = RA_LEVEL; // assuming level flight for now
+      tcas_acs_status[ti_acs_id[tcas_ac_RA]].resolve = RA_LEVEL; // assuming level flight for now
     } else { // second resolution or message received
       if (ac_resolve != RA_LEVEL) { // message received
         if (ac_resolve == tcas_resolve) { // same direction, lowest id go down
@@ -201,8 +201,8 @@ void tcas_periodic_task_1Hz(void)
           else { tcas_resolve = RA_CLIMB; }
         }
       } else { // no message
-        if (tcas_resolve == RA_CLIMB && the_acs[the_acs_id[tcas_ac_RA]].climb > 1.0) { tcas_resolve = RA_DESCEND; } // revert resolve
-        else if (tcas_resolve == RA_DESCEND && the_acs[the_acs_id[tcas_ac_RA]].climb < -1.0) { tcas_resolve = RA_CLIMB; } // revert resolve
+        if (tcas_resolve == RA_CLIMB && ti_acs[ti_acs_id[tcas_ac_RA]].climb > 1.0) { tcas_resolve = RA_DESCEND; } // revert resolve
+        else if (tcas_resolve == RA_DESCEND && ti_acs[ti_acs_id[tcas_ac_RA]].climb < -1.0) { tcas_resolve = RA_CLIMB; } // revert resolve
       }
     }
     // Downlink alert
@@ -223,10 +223,10 @@ void tcas_periodic_task_4Hz(void)
     struct ac_info_ * ac = get_ac_info(tcas_ac_RA);
     switch (tcas_resolve) {
       case RA_CLIMB :
-        tcas_alt_setpoint = Max(nav_altitude, ac->alt + tcas_alim);
+        tcas_alt_setpoint = Max(nav_altitude, ac->utm.alt/1000. + tcas_alim);
         break;
       case RA_DESCEND :
-        tcas_alt_setpoint = Min(nav_altitude, ac->alt - tcas_alim);
+        tcas_alt_setpoint = Min(nav_altitude, ac->utm.alt/1000. - tcas_alim);
         break;
       case RA_LEVEL :
       case RA_NONE :
diff --git a/sw/airborne/modules/multi/tcas.h b/sw/airborne/modules/multi/tcas.h
index 411b23a..5cd977e 100644
--- a/sw/airborne/modules/multi/tcas.h
+++ b/sw/airborne/modules/multi/tcas.h
@@ -29,7 +29,7 @@
 #define TCAS_H
 
 #include "std.h"
-#include "subsystems/navigation/traffic_info.h"
+#include "modules/multi/traffic_info.h"
 
 extern float tcas_alt_setpoint;
 extern float tcas_tau_ta, tcas_tau_ra, tcas_dmod, tcas_alim;
diff --git a/sw/airborne/state.c b/sw/airborne/state.c
index ade27cd..180b8ae 100644
--- a/sw/airborne/state.c
+++ b/sw/airborne/state.c
@@ -310,33 +310,41 @@ void stateCalcPositionLla_i(void)
   SetBit(state.pos_status, POS_LLA_I);
 }
 
+/**
+ * Calculate UTM (float) from any other available representation.
+ * Note that since LLA in float has bad precision but is more accurate
+ * as you move further away from origin.
+ */
 void stateCalcPositionUtm_f(void)
 {
   if (bit_is_set(state.pos_status, POS_UTM_F)) {
     return;
   }
 
-  if (bit_is_set(state.pos_status, POS_LLA_F)) {
-    utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
+  if (bit_is_set(state.pos_status, POS_UTM_I)) {
+    UTM_FLOAT_OF_BFP(state.utm_pos_f, state.utm_pos_i);
   } else if (bit_is_set(state.pos_status, POS_LLA_I)) {
-    /* transform lla_i -> lla_f -> utm_f, set status bits */
-    LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
-    SetBit(state.pos_status, POS_LLA_F);
+    utm_of_lla_i(&state.utm_pos_i, &state.lla_pos_i);
+    // TODO set utm alt in hmsl
+    SetBit(state.pos_status, POS_UTM_I);
+    UTM_FLOAT_OF_BFP(state.utm_pos_f, state.utm_pos_i);
+  } else if (bit_is_set(state.pos_status, POS_LLA_F)) {
     utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
+    // TODO set utm alt in hmsl
   } else if (state.utm_initialized_f) {
     if (bit_is_set(state.pos_status, POS_ENU_F)) {
       UTM_OF_ENU_ADD(state.utm_pos_f, state.enu_pos_f, state.utm_origin_f);
-    } else if (bit_is_set(state.pos_status, POS_ENU_I)) {
-      ENU_FLOAT_OF_BFP(state.enu_pos_f, state.enu_pos_i);
-      SetBit(state.pos_status, POS_ENU_F);
-      UTM_OF_ENU_ADD(state.utm_pos_f, state.enu_pos_f, state.utm_origin_f);
     } else if (bit_is_set(state.pos_status, POS_NED_F)) {
       UTM_OF_NED_ADD(state.utm_pos_f, state.ned_pos_f, state.utm_origin_f);
+    } /*else if (bit_is_set(state.pos_status, POS_ENU_I)) {
+      UTM_OF_ENU_ADD(state.utm_pos_i, state.enu_pos_i, state.utm_origin_i);
+      SetBit(state.pos_status, POS_UTM_I);
+      UTM_FLOAT_OF_BFP(state.utm_pos_f, state.utm_pos_i);
     } else if (bit_is_set(state.pos_status, POS_NED_I)) {
-      NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
-      SetBit(state.pos_status, POS_NED_F);
-      UTM_OF_NED_ADD(state.utm_pos_f, state.ned_pos_f, state.utm_origin_f);
-    }
+      UTM_OF_NED_ADD(state.utm_pos_i, state.ned_pos_i, state.utm_origin_i);
+      SetBit(state.pos_status, POS_UTM_I);
+      UTM_FLOAT_OF_BFP(state.utm_pos_f, state.utm_pos_i);
+    }*/
   } else {
     /* could not get this representation,  set errno */
     //struct EcefCoor_f _ecef_zero = {0.0f};
@@ -346,6 +354,48 @@ void stateCalcPositionUtm_f(void)
   SetBit(state.pos_status, POS_UTM_F);
 }
 
+/**
+ * Calculate UTM (int) from any other available representation.
+ * Note that since LLA in float has bad precision but is more accurate
+ * as you move further away from origin.
+ */
+void stateCalcPositionUtm_i(void)
+{
+  if (bit_is_set(state.pos_status, POS_UTM_I)) {
+    return;
+  }
+
+  if (bit_is_set(state.pos_status, POS_LLA_I)) {
+    state.utm_pos_i.zone = 0;
+    utm_of_lla_i(&state.utm_pos_i, &state.lla_pos_i);
+    // TODO set utm alt in hmsl
+  } else if (bit_is_set(state.pos_status, POS_LLA_F)) {
+    state.utm_pos_i.zone = 0;
+    utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
+    // TODO set utm alt in hmsl
+    SetBit(state.pos_status, POS_UTM_F);
+    UTM_BFP_OF_REAL(state.utm_pos_i, state.utm_pos_f);
+  } /* else if (bit_is_set(state.pos_status, POS_ENU_I)) {
+    UTM_OF_ENU_ADD(state.utm_pos_i, state.enu_pos_i, state.utm_origin_i);
+  } else if (bit_is_set(state.pos_status, POS_NED_I)) {
+    UTM_OF_NED_ADD(state.utm_pos_i, state.ned_pos_i, state.utm_origin_i);
+  } else*/ if (bit_is_set(state.pos_status, POS_ENU_F)) {
+    UTM_OF_ENU_ADD(state.utm_pos_f, state.enu_pos_f, state.utm_origin_f);
+    SetBit(state.pos_status, POS_UTM_F);
+    UTM_BFP_OF_REAL(state.utm_pos_i, state.utm_pos_f);
+  } else if (bit_is_set(state.pos_status, POS_NED_F)) {
+    UTM_OF_NED_ADD(state.utm_pos_f, state.ned_pos_f, state.utm_origin_f);
+    SetBit(state.pos_status, POS_UTM_F);
+    UTM_BFP_OF_REAL(state.utm_pos_i, state.utm_pos_f);
+  } else {
+    /* could not get this representation,  set errno */
+    //struct EcefCoor_f _ecef_zero = {0.0f};
+    //return _ecef_zero;
+  }
+  /* set bit to indicate this representation is computed */
+  SetBit(state.pos_status, POS_UTM_I);
+}
+
 void stateCalcPositionEcef_f(void)
 {
   if (bit_is_set(state.pos_status, POS_ECEF_F)) {
diff --git a/sw/airborne/state.h b/sw/airborne/state.h
index cb25128..0f8fe3d 100644
--- a/sw/airborne/state.h
+++ b/sw/airborne/state.h
@@ -184,10 +184,10 @@ struct State {
 
   /**
    * Position in UTM coordinates.
-   * Units x,y: meters.
-   * Units z: meters above MSL
+   * Units x,y: centimetres.
+   * Units z: millimetres above MSL
    */
-  struct UtmCoor_f utm_pos_f;
+  struct UtmCoor_i utm_pos_i;
 
   /**
    * Altitude above ground level.
@@ -209,15 +209,22 @@ struct State {
   struct EcefCoor_f ecef_pos_f;
 
   /**
+     * Position in UTM coordinates.
+     * Units x,y: meters.
+     * Units z: meters above MSL
+     */
+    struct UtmCoor_f utm_pos_f;
+
+  /**
    * Definition of the local (flat earth) coordinate system.
    * Defines the origin of the local NorthEastDown coordinate system
    * in ECEF (EarthCenteredEarthFixed) and LLA (LatitudeLongitudeAlt)
-   * coordinates and the roation matrix from ECEF to local frame.
+   * coordinates and the rotation matrix from ECEF to local frame.
    * (float version)
    */
   struct LtpDef_f ned_origin_f;
 
-  /// True if local float coordinate frame is initialsed
+  /// True if local float coordinate frame is initialised
   bool ned_initialized_f;
 
   /**
@@ -225,11 +232,23 @@ struct State {
    * Defines the origin of the local NorthEastDown coordinate system
    * in UTM coordinates, used as a reference when ned_origin is not
    * initialized.
+   * (int version)
+   */
+  struct UtmCoor_i utm_origin_i;
+
+  /// True if utm origin (int) coordinate frame is initialised
+  bool utm_initialized_i;
+
+  /**
+   * Definition of the origin of Utm coordinate system.
+   * Defines the origin of the local NorthEastDown coordinate system
+   * in UTM coordinates, used as a reference when ned_origin is not
+   * initialized.
    * (float version)
    */
   struct UtmCoor_f utm_origin_f;
 
-  /// True if utm origin (float) coordinate frame is initialsed
+  /// True if utm origin (int) coordinate frame is initialised
   bool utm_initialized_f;
 
   /**
@@ -438,6 +457,22 @@ extern void stateInit(void);
 /** @addtogroup state_position
  *  @{ */
 
+/// Set the local (flat earth) coordinate frame origin from UTM (int).
+static inline void stateSetLocalUtmOrigin_i(struct UtmCoor_i *utm_def)
+{
+  state.utm_origin_i = *utm_def;
+  state.utm_initialized_i = TRUE;
+
+  UTM_FLOAT_OF_BFP(state.utm_origin_f, state.utm_origin_i);
+  state.utm_initialized_f = TRUE;
+
+  /* clear bits for all local frame representations */
+  state.pos_status &= ~(POS_LOCAL_COORD);
+  state.speed_status &= ~(SPEED_LOCAL_COORD);
+  ClearBit(state.accel_status, ACCEL_NED_I);
+  ClearBit(state.accel_status, ACCEL_NED_F);
+}
+
 /// Set the local (flat earth) coordinate frame origin (int).
 static inline void stateSetLocalOrigin_i(struct LtpDef_i *ltp_def)
 {
@@ -456,19 +491,19 @@ static inline void stateSetLocalOrigin_i(struct LtpDef_i *ltp_def)
 
   state.ned_initialized_i = true;
   state.ned_initialized_f = true;
+
+  struct UtmCoor_i utm_def;
+  utm_of_lla_i(&utm_def, &state.ned_origin_i.lla);
+  stateSetLocalUtmOrigin_i(&utm_def);
+  state.utm_initialized_i = true;
 }
 
 /// Set the local (flat earth) coordinate frame origin from UTM (float).
-static inline void stateSetLocalUtmOrigin_f(struct UtmCoor_f *utm_def)
+static inline void stateSetLocalUtmOrigin_f(struct UtmCoor_f *utm_def_f)
 {
-  state.utm_origin_f = *utm_def;
-  state.utm_initialized_f = true;
-
-  /* clear bits for all local frame representations */
-  state.pos_status &= ~(POS_LOCAL_COORD);
-  state.speed_status &= ~(SPEED_LOCAL_COORD);
-  ClearBit(state.accel_status, ACCEL_NED_I);
-  ClearBit(state.accel_status, ACCEL_NED_F);
+  struct UtmCoor_i utm_def;
+  UTM_BFP_OF_REAL(utm_def,*utm_def_f);
+  stateSetLocalUtmOrigin_i(&utm_def);
 }
 /*******************************************************************************
  *                                                                             *
@@ -477,6 +512,7 @@ static inline void stateSetLocalUtmOrigin_f(struct UtmCoor_f *utm_def)
  ******************************************************************************/
 
 /************* declaration of transformation functions ************/
+extern void stateCalcPositionUtm_i(void);
 extern void stateCalcPositionEcef_i(void);
 extern void stateCalcPositionNed_i(void);
 extern void stateCalcPositionEnu_i(void);
@@ -541,7 +577,8 @@ static inline void stateSetPosition_i(
   struct EcefCoor_i *ecef_pos,
   struct NedCoor_i *ned_pos,
   struct EnuCoor_i *enu_pos,
-  struct LlaCoor_i *lla_pos)
+  struct LlaCoor_i *lla_pos,
+  struct UtmCoor_i *utm_pos)
 {
   /* clear all status bit */
   state.pos_status = 0;
@@ -561,6 +598,18 @@ static inline void stateSetPosition_i(
     LLA_COPY(state.lla_pos_i, *lla_pos);
     state.pos_status |= (1 << POS_LLA_I);
   }
+  if (utm_pos != NULL) {
+    UTM_COPY(state.utm_pos_i, *utm_pos);
+    state.pos_status |= (1 << POS_UTM_I);
+  }
+}
+
+/// Set position from UTM coordinates (int).
+static inline void stateSetPositionUtm_i(struct UtmCoor_i *utm_pos)
+{
+  state.utm_pos_i = *utm_pos;
+  /* clear bits for all position representations and only set the new one */
+  state.pos_status = (1 << POS_UTM_I);
 }
 
 /// Set position from UTM coordinates (float).
@@ -673,6 +722,15 @@ static inline struct LlaCoor_i *stateGetPositionLla_i(void)
   return &state.lla_pos_i;
 }
 
+/// Get position in UTM coordinates (int).
+static inline struct UtmCoor_i *stateGetPositionUtm_i(void)
+{
+  if (!bit_is_set(state.pos_status, POS_UTM_I)) {
+    stateCalcPositionUtm_i();
+  }
+  return &state.utm_pos_i;
+}
+
 /// Get position in UTM coordinates (float).
 static inline struct UtmCoor_f *stateGetPositionUtm_f(void)
 {
diff --git a/sw/airborne/subsystems/datalink/datalink.c b/sw/airborne/subsystems/datalink/datalink.c
index 986168c..2ef4d17 100644
--- a/sw/airborne/subsystems/datalink/datalink.c
+++ b/sw/airborne/subsystems/datalink/datalink.c
@@ -35,7 +35,6 @@
 #include "generated/settings.h"
 
 #include "pprzlink/messages.h"
-#include "pprzlink/dl_protocol.h"
 
 #if defined RADIO_CONTROL && defined RADIO_CONTROL_TYPE_DATALINK
 #include "subsystems/radio_control.h"
@@ -48,15 +47,12 @@
 #include "subsystems/gps/gps_datalink.h"
 #endif
 
-#ifdef TRAFFIC_INFO
-#include "subsystems/navigation/traffic_info.h"
-#endif
-
 #ifdef RADIO_CONTROL_DATALINK_LED
 #include "led.h"
 #endif
 
 #define MOfCm(_x) (((float)(_x))/100.)
+#define MOfMm(_x) (((float)(_x))/1000.)
 
 #if USE_NPS
 bool datalink_enabled = true;
@@ -70,60 +66,6 @@ void dl_parse_msg(void)
   /* parse telemetry messages coming from other AC */
   if (sender_id != 0) {
     switch (msg_id) {
-#if 0   // TODO waiting for telemetry macros to be made in pprzlink
-#ifdef TRAFFIC_INFO
-      case DL_GPS_SMALL: {
-        uint32_t multiplex_speed = DL_GPS_SMALL_multiplex_speed(dl_buffer);
-
-        // Position in ENU coordinates
-        int16_t course = (int16_t)((multiplex_speed >> 21) & 0x7FF); // bits 31-21 course in decideg
-        if (course & 0x400) {
-          course |= 0xFFFFF800;  // fix for twos complements
-        }
-        int16_t gspeed = (int16_t)((multiplex_speed >> 10) & 0x7FF); // bits 20-10 ground speed cm/s
-        if (gspeed & 0x400) {
-          gspeed |= 0xFFFFF800;  // fix for twos complements
-        }
-        int16_t climb = (int16_t)(multiplex_speed >> 2 & 0x7FF); // bits 9-0 z climb speed in cm/s
-        if (climb & 0x400) {
-          climb |= 0xFFFFF800;  // fix for twos complements
-        }
-
-        set_ac_info(sender_id,
-                    MOfCm(DL_GPS_SMALL_utm_east(dl_buffer)),    /*m*/
-                    MOfCm(DL_GPS_SMALL_utm_north(dl_buffer)),   /*m*/
-                    RadOfDeg(((float)course) / 10.),            /*rad(CW)*/
-                    MOfCm(DL_GPS_SMALL_alt(dl_buffer)),         /*m*/
-                    MOfCm(gspeed),                              /*m/s*/
-                    MOfCm(climb),                               /*m/s*/
-                    gps_tow_from_sys_ticks(sys_time.nb_tick));
-      }
-      break;
-
-      case DL_GPS: {
-        set_ac_info(sender_id,
-          MOfCm(DL_GPS_utm_east(dl_buffer)),    /*m*/
-          MOfCm(DL_GPS_utm_north(dl_buffer)),   /*m*/
-          RadOfDeg(((float)DL_GPS_course(dl_buffer)) / 10.), /*rad(CW)*/
-          MOfCm(DL_GPS_alt(dl_buffer)),        /*m*/
-          MOfCm(DL_GPS_speed(dl_buffer)),       /*m/s*/
-          MOfCm(DL_GPS_climb(dl_buffer)),       /*m/s*/
-          (uint32_t)DL_GPS_itow(dl_buffer));
-      }
-      break;
-      case DL_GPS_LLA: {
-        set_ac_info_lla(sender_id,
-                        DL_GPS_LLA_lat(dl_buffer),    /*1e7deg*/
-                        DL_GPS_LLA_lon(dl_buffer),    /*1e7deg*/
-                        DL_GPS_LLA_alt(dl_buffer),    /*mm*/
-                        DL_GPS_LLA_course(dl_buffer), /*decideg*/
-                        DL_GPS_LLA_speed(dl_buffer),  /*cm/s*/
-                        DL_GPS_LLA_climb(dl_buffer),  /*cm/s*/
-                        DL_GPS_LLA_itow(dl_buffer));  /*ms*/
-      }
-      break;
-#endif /* TRAFFIC_INFO */
-
 #ifdef TCAS
       case DL_TCAS_RA: {
         if (DL_TCAS_RESOLVE_ac_id(dl_buffer) == AC_ID && SenderIdOfMsg(dl_buffer) != AC_ID) {
@@ -132,130 +74,113 @@ void dl_parse_msg(void)
         }
       }
 #endif /* TCAS */
-#endif
       default: {
         break;
       }
     }
-    return;  // msg was telemetry not datalink so return
-  }
-
-  /* parse telemetry messages coming from ground station */
-  switch (msg_id) {
-    case  DL_PING: {
-      DOWNLINK_SEND_PONG(DefaultChannel, DefaultDevice);
-    }
-    break;
+  } else {
+    /* parse telemetry messages coming from ground station */
+    switch (msg_id) {
+      case  DL_PING: {
+        DOWNLINK_SEND_PONG(DefaultChannel, DefaultDevice);
+      }
+      break;
 
-    case DL_SETTING : {
-      if (DL_SETTING_ac_id(dl_buffer) != AC_ID) { break; }
-      uint8_t i = DL_SETTING_index(dl_buffer);
-      float var = DL_SETTING_value(dl_buffer);
-      DlSetting(i, var);
-      DOWNLINK_SEND_DL_VALUE(DefaultChannel, DefaultDevice, &i, &var);
-    }
-    break;
+      case DL_SETTING : {
+        if (DL_SETTING_ac_id(dl_buffer) != AC_ID) { break; }
+        uint8_t i = DL_SETTING_index(dl_buffer);
+        float var = DL_SETTING_value(dl_buffer);
+        DlSetting(i, var);
+        DOWNLINK_SEND_DL_VALUE(DefaultChannel, DefaultDevice, &i, &var);
+      }
+      break;
 
-    case DL_GET_SETTING : {
-      if (DL_GET_SETTING_ac_id(dl_buffer) != AC_ID) { break; }
-      uint8_t i = DL_GET_SETTING_index(dl_buffer);
-      float val = settings_get_value(i);
-      DOWNLINK_SEND_DL_VALUE(DefaultChannel, DefaultDevice, &i, &val);
-    }
-    break;
+      case DL_GET_SETTING : {
+        if (DL_GET_SETTING_ac_id(dl_buffer) != AC_ID) { break; }
+        uint8_t i = DL_GET_SETTING_index(dl_buffer);
+        float val = settings_get_value(i);
+        DOWNLINK_SEND_DL_VALUE(DefaultChannel, DefaultDevice, &i, &val);
+      }
+      break;
 
-#ifdef RADIO_CONTROL_TYPE_DATALINK
-    case DL_RC_3CH :
+  #ifdef RADIO_CONTROL_TYPE_DATALINK
+      case DL_RC_3CH :
 #ifdef RADIO_CONTROL_DATALINK_LED
-      LED_TOGGLE(RADIO_CONTROL_DATALINK_LED);
+        LED_TOGGLE(RADIO_CONTROL_DATALINK_LED);
 #endif
-      parse_rc_3ch_datalink(
-        DL_RC_3CH_throttle_mode(dl_buffer),
-        DL_RC_3CH_roll(dl_buffer),
-        DL_RC_3CH_pitch(dl_buffer));
-      break;
-    case DL_RC_4CH :
-      if (DL_RC_4CH_ac_id(dl_buffer) == AC_ID) {
+        parse_rc_3ch_datalink(
+          DL_RC_3CH_throttle_mode(dl_buffer),
+          DL_RC_3CH_roll(dl_buffer),
+          DL_RC_3CH_pitch(dl_buffer));
+        break;
+      case DL_RC_4CH :
+        if (DL_RC_4CH_ac_id(dl_buffer) == AC_ID) {
 #ifdef RADIO_CONTROL_DATALINK_LED
-        LED_TOGGLE(RADIO_CONTROL_DATALINK_LED);
+          LED_TOGGLE(RADIO_CONTROL_DATALINK_LED);
 #endif
-        parse_rc_4ch_datalink(DL_RC_4CH_mode(dl_buffer),
-                              DL_RC_4CH_throttle(dl_buffer),
-                              DL_RC_4CH_roll(dl_buffer),
-                              DL_RC_4CH_pitch(dl_buffer),
-                              DL_RC_4CH_yaw(dl_buffer));
-      }
-      break;
+          parse_rc_4ch_datalink(DL_RC_4CH_mode(dl_buffer),
+                                DL_RC_4CH_throttle(dl_buffer),
+                                DL_RC_4CH_roll(dl_buffer),
+                                DL_RC_4CH_pitch(dl_buffer),
+                                DL_RC_4CH_yaw(dl_buffer));
+        }
+        break;
 #endif // RADIO_CONTROL_TYPE_DATALINK
 
 #if USE_GPS
 #ifdef GPS_DATALINK
-    case DL_REMOTE_GPS_SMALL : {
-      // Check if the GPS is for this AC
-      if (DL_REMOTE_GPS_SMALL_ac_id(dl_buffer) != AC_ID) { break; }
-
-      parse_gps_datalink_small(
-        DL_REMOTE_GPS_SMALL_numsv(dl_buffer),
-        DL_REMOTE_GPS_SMALL_pos_xyz(dl_buffer),
-        DL_REMOTE_GPS_SMALL_speed_xyz(dl_buffer),
-        DL_REMOTE_GPS_SMALL_heading(dl_buffer));
-    }
-    break;
-
-    case DL_REMOTE_GPS : {
-      // Check if the GPS is for this AC
-      if (DL_REMOTE_GPS_ac_id(dl_buffer) != AC_ID) { break; }
+      case DL_REMOTE_GPS_SMALL : {
+        // Check if the GPS is for this AC
+        if (DL_REMOTE_GPS_SMALL_ac_id(dl_buffer) != AC_ID) { break; }
+
+        parse_gps_datalink_small(
+            DL_REMOTE_GPS_SMALL_heading(dl_buffer),
+            DL_REMOTE_GPS_SMALL_pos_xyz(dl_buffer),
+            DL_REMOTE_GPS_SMALL_speed_xyz(dl_buffer),
+            DL_REMOTE_GPS_SMALL_tow(dl_buffer));
+      }
+      break;
 
-      // Parse the GPS
-      parse_gps_datalink(
-        DL_REMOTE_GPS_numsv(dl_buffer),
-        DL_REMOTE_GPS_ecef_x(dl_buffer),
-        DL_REMOTE_GPS_ecef_y(dl_buffer),
-        DL_REMOTE_GPS_ecef_z(dl_buffer),
-        DL_REMOTE_GPS_lat(dl_buffer),
-        DL_REMOTE_GPS_lon(dl_buffer),
-        DL_REMOTE_GPS_alt(dl_buffer),
-        DL_REMOTE_GPS_hmsl(dl_buffer),
-        DL_REMOTE_GPS_ecef_xd(dl_buffer),
-        DL_REMOTE_GPS_ecef_yd(dl_buffer),
-        DL_REMOTE_GPS_ecef_zd(dl_buffer),
-        DL_REMOTE_GPS_tow(dl_buffer),
-        DL_REMOTE_GPS_course(dl_buffer));
-    }
-    break;
+      case DL_REMOTE_GPS : {
+        // Check if the GPS is for this AC
+        if (DL_REMOTE_GPS_ac_id(dl_buffer) != AC_ID) { break; }
+
+        // Parse the GPS
+        parse_gps_datalink(
+          DL_REMOTE_GPS_numsv(dl_buffer),
+          DL_REMOTE_GPS_ecef_x(dl_buffer),
+          DL_REMOTE_GPS_ecef_y(dl_buffer),
+          DL_REMOTE_GPS_ecef_z(dl_buffer),
+          DL_REMOTE_GPS_lat(dl_buffer),
+          DL_REMOTE_GPS_lon(dl_buffer),
+          DL_REMOTE_GPS_alt(dl_buffer),
+          DL_REMOTE_GPS_hmsl(dl_buffer),
+          DL_REMOTE_GPS_ecef_xd(dl_buffer),
+          DL_REMOTE_GPS_ecef_yd(dl_buffer),
+          DL_REMOTE_GPS_ecef_zd(dl_buffer),
+          DL_REMOTE_GPS_tow(dl_buffer),
+          DL_REMOTE_GPS_course(dl_buffer));
+      }
+      break;
 #endif // GPS_DATALINK
 
-    case DL_GPS_INJECT : {
-      // Check if the GPS is for this AC
-      if (DL_GPS_INJECT_ac_id(dl_buffer) != AC_ID) { break; }
+      case DL_GPS_INJECT : {
+        // Check if the GPS is for this AC
+        if (DL_GPS_INJECT_ac_id(dl_buffer) != AC_ID) { break; }
 
-      // GPS parse data
-      gps_inject_data(
-        DL_GPS_INJECT_packet_id(dl_buffer),
-        DL_GPS_INJECT_data_length(dl_buffer),
-        DL_GPS_INJECT_data(dl_buffer)
-      );
-    }
-    break;
+        // GPS parse data
+        gps_inject_data(
+          DL_GPS_INJECT_packet_id(dl_buffer),
+          DL_GPS_INJECT_data_length(dl_buffer),
+          DL_GPS_INJECT_data(dl_buffer)
+        );
+      }
+      break;
 #endif  // USE_GPS
 
-#ifdef TRAFFIC_INFO
-    case DL_ACINFO: {
-      if (DL_ACINFO_ac_id(dl_buffer) == AC_ID) { break; }
-      uint8_t id = DL_ACINFO_ac_id(dl_buffer);
-      float ux = MOfCm(DL_ACINFO_utm_east(dl_buffer));
-      float uy = MOfCm(DL_ACINFO_utm_north(dl_buffer));
-      float a = MOfCm(DL_ACINFO_alt(dl_buffer));
-      float c = RadOfDeg(((float)DL_ACINFO_course(dl_buffer)) / 10.);
-      float s = MOfCm(DL_ACINFO_speed(dl_buffer));
-      float cl = MOfCm(DL_ACINFO_climb(dl_buffer));
-      uint32_t t = DL_ACINFO_itow(dl_buffer);
-      set_ac_info(id, ux, uy, c, a, s, cl, t);
+      default:
+        break;
     }
-    break;
-#endif
-    default:
-      break;
   }
   /* Parse firmware specific datalink */
   firmware_parse_msg();
@@ -264,7 +189,7 @@ void dl_parse_msg(void)
   modules_parse_datalink(msg_id);
 }
 
-/* default emtpy WEAK implementation for firmwares without an extra firmware_parse_msg */
+/* default empty WEAK implementation for firmwares without an extra firmware_parse_msg */
 WEAK void firmware_parse_msg(void)
 {
 }
diff --git a/sw/airborne/subsystems/gps.c b/sw/airborne/subsystems/gps.c
index 5157175..66713ee 100644
--- a/sw/airborne/subsystems/gps.c
+++ b/sw/airborne/subsystems/gps.c
@@ -231,6 +231,11 @@ static void gps_cb(uint8_t sender_id,
   gps = *gps_s;
   AbiSendMsgGPS(GPS_MULTI_ID, now_ts, gps_s);
 #endif
+  if (gps.tow != gps_time_sync.t0_tow)
+  {
+    gps_time_sync.t0_ticks = sys_time.nb_tick;
+    gps_time_sync.t0_tow = gps.tow;
+  }
 }
 
 /*
@@ -342,25 +347,20 @@ void WEAK gps_inject_data(uint8_t packet_id __attribute__((unused)), uint8_t len
 struct UtmCoor_f utm_float_from_gps(struct GpsState *gps_s, uint8_t zone)
 {
   struct UtmCoor_f utm;
-  utm.alt = 0.f;
+  utm.zone = zone;
 
   if (bit_is_set(gps_s->valid_fields, GPS_VALID_POS_UTM_BIT)) {
     // A real UTM position is available, use the correct zone
     utm.zone = gps_s->utm_pos.zone;
     utm.east = gps_s->utm_pos.east / 100.0f;
     utm.north = gps_s->utm_pos.north / 100.0f;
+    utm.alt = gps_s->utm_pos.alt / 1000.f;
   }
   else {
-    struct LlaCoor_f lla;
-    LLA_FLOAT_OF_BFP(lla, gps_s->lla_pos);
-    // Check if zone should be computed
-    if (zone > 0) {
-      utm.zone = zone;
-    } else {
-      utm.zone = (gps_s->lla_pos.lon / 1e7 + 180) / 6 + 1;
-    }
-    /* Recompute UTM coordinates in this zone */
-    utm_of_lla_f(&utm, &lla);
+    struct UtmCoor_i utm_i;
+
+    utm_of_lla_i(&utm_i, &gps_s->lla_pos);
+    UTM_FLOAT_OF_BFP(utm, utm_i);
   }
 
   return utm;
@@ -369,30 +369,18 @@ struct UtmCoor_f utm_float_from_gps(struct GpsState *gps_s, uint8_t zone)
 struct UtmCoor_i utm_int_from_gps(struct GpsState *gps_s, uint8_t zone)
 {
   struct UtmCoor_i utm;
-  utm.alt = 0;
+  utm.zone = zone;
 
   if (bit_is_set(gps_s->valid_fields, GPS_VALID_POS_UTM_BIT)) {
     // A real UTM position is available, use the correct zone
     utm.zone = gps_s->utm_pos.zone;
     utm.east = gps_s->utm_pos.east;
     utm.north = gps_s->utm_pos.north;
+    utm.alt = gps_s->utm_pos.alt;
   }
   else {
-    struct LlaCoor_f lla;
-    LLA_FLOAT_OF_BFP(lla, gps_s->lla_pos);
-    // Check if zone should be computed
-    if (zone > 0) {
-      utm.zone = zone;
-    } else {
-      utm.zone = (gps_s->lla_pos.lon / 1e7 + 180) / 6 + 1;
-    }
     /* Recompute UTM coordinates in this zone */
-    struct UtmCoor_f utm_f;
-    utm_f.zone = utm.zone;
-    utm_of_lla_f(&utm_f, &lla);
-    /* convert to fixed point in cm */
-    utm.east = utm_f.east * 100;
-    utm.north = utm_f.north * 100;
+    utm_of_lla_i(&utm, &gps_s->lla_pos);
   }
 
   return utm;
diff --git a/sw/airborne/subsystems/gps/gps_datalink.c b/sw/airborne/subsystems/gps/gps_datalink.c
index 9bf1bb1..f2cc999 100644
--- a/sw/airborne/subsystems/gps/gps_datalink.c
+++ b/sw/airborne/subsystems/gps/gps_datalink.c
@@ -32,10 +32,7 @@
 #include "subsystems/gps.h"
 #include "subsystems/abi.h"
 
-// #include <stdio.h>
-
 struct LtpDef_i ltp_def;
-struct EnuCoor_i enu_pos, enu_speed;
 
 struct GpsState gps_datalink;
 
@@ -43,8 +40,10 @@ struct GpsState gps_datalink;
 void gps_datalink_init(void)
 {
   gps_datalink.fix = GPS_FIX_NONE;
-  gps_datalink.gspeed = 700; // To enable course setting
-  gps_datalink.cacc = 0; // To enable course setting
+  gps_datalink.pdop = 0;
+  gps_datalink.sacc = 0;
+  gps_datalink.pacc = 0;
+  gps_datalink.cacc = 0;
 
   struct LlaCoor_i llh_nav0; /* Height above the ellipsoid */
   llh_nav0.lat = NAV_LAT0;
@@ -52,14 +51,14 @@ void gps_datalink_init(void)
   /* NAV_ALT0 = ground alt above msl, NAV_MSL0 = geoid-height (msl) over ellipsoid */
   llh_nav0.alt = NAV_ALT0 + NAV_MSL0;
 
-  struct EcefCoor_i ecef_nav0;
-  ecef_of_lla_i(&ecef_nav0, &llh_nav0);
-  ltp_def_from_ecef_i(&ltp_def, &ecef_nav0);
+  ltp_def_from_lla_i(&ltp_def, &llh_nav0);
 }
 
 // Parse the REMOTE_GPS_SMALL datalink packet
-void parse_gps_datalink_small(uint8_t num_sv, uint32_t pos_xyz, uint32_t speed_xyz, int16_t heading)
+void parse_gps_datalink_small(int16_t heading, uint32_t pos_xyz, uint32_t speed_xyz, uint32_t tow)
 {
+  struct EnuCoor_i enu_pos, enu_speed;
+
   // Position in ENU coordinates
   enu_pos.x = (int32_t)((pos_xyz >> 21) & 0x7FF); // bits 31-21 x position in cm
   if (enu_pos.x & 0x400) {
@@ -91,13 +90,14 @@ void parse_gps_datalink_small(uint8_t num_sv, uint32_t pos_xyz, uint32_t speed_x
     enu_speed.z |= 0xFFFFFC00;  // sign extend for twos complements
   }
 
+  VECT3_NED_OF_ENU(gps_datalink.ned_vel, enu_speed);
+  SetBit(gps_datalink.valid_fields, GPS_VALID_VEL_NED_BIT);
+
   ecef_of_enu_vect_i(&gps_datalink.ecef_vel , &ltp_def , &enu_speed);
   SetBit(gps_datalink.valid_fields, GPS_VALID_VEL_ECEF_BIT);
 
-  gps_datalink.ned_vel.x = enu_speed.y;
-  gps_datalink.ned_vel.y = enu_speed.x;
-  gps_datalink.ned_vel.z = -enu_speed.z;
-  SetBit(gps_datalink.valid_fields, GPS_VALID_VEL_NED_BIT);
+  gps_datalink.gspeed = (int16_t)FLOAT_VECT2_NORM(enu_speed);
+  gps_datalink.speed_3d = (int16_t)FLOAT_VECT3_NORM(enu_speed);
 
   gps_datalink.hmsl = ltp_def.hmsl + enu_pos.z * 10;
   SetBit(gps_datalink.valid_fields, GPS_VALID_HMSL_BIT);
@@ -105,18 +105,18 @@ void parse_gps_datalink_small(uint8_t num_sv, uint32_t pos_xyz, uint32_t speed_x
   gps_datalink.course = ((int32_t)heading) * 1e3;
   SetBit(gps_datalink.valid_fields, GPS_VALID_COURSE_BIT);
 
-  gps_datalink.num_sv = num_sv;
-  gps_datalink.tow = gps_tow_from_sys_ticks(sys_time.nb_tick);
+  gps_datalink.num_sv = 7;
+  gps_datalink.tow = tow;
   gps_datalink.fix = GPS_FIX_3D; // set 3D fix to true
 
   // publish new GPS data
   uint32_t now_ts = get_sys_time_usec();
   gps_datalink.last_msg_ticks = sys_time.nb_sec_rem;
   gps_datalink.last_msg_time = sys_time.nb_sec;
-  if (gps_datalink.fix == GPS_FIX_3D) {
-    gps_datalink.last_3dfix_ticks = sys_time.nb_sec_rem;
-    gps_datalink.last_3dfix_time = sys_time.nb_sec;
-  }
+
+  gps_datalink.last_3dfix_ticks = sys_time.nb_sec_rem;
+  gps_datalink.last_3dfix_time = sys_time.nb_sec;
+
   AbiSendMsgGPS(GPS_DATALINK_ID, now_ts, &gps_datalink);
 }
 
@@ -143,30 +143,27 @@ void parse_gps_datalink(uint8_t numsv, int32_t ecef_x, int32_t ecef_y, int32_t e
   gps_datalink.ecef_vel.z = ecef_zd;
   SetBit(gps_datalink.valid_fields, GPS_VALID_VEL_ECEF_BIT);
 
-  gps_datalink.ned_vel.x = enu_speed.y;
-  gps_datalink.ned_vel.y = enu_speed.x;
-  gps_datalink.ned_vel.z = -enu_speed.z;
+  ned_of_ecef_vect_i(&gps_datalink.ned_vel, &ltp_def , &gps_datalink.ecef_vel);
   SetBit(gps_datalink.valid_fields, GPS_VALID_VEL_NED_BIT);
 
+  gps_datalink.gspeed = (int16_t)FLOAT_VECT2_NORM(gps_datalink.ned_vel);
+  gps_datalink.speed_3d = (int16_t)FLOAT_VECT3_NORM(gps_datalink.ned_vel);
+
   gps_datalink.course = course;
   SetBit(gps_datalink.valid_fields, GPS_VALID_COURSE_BIT);
 
   gps_datalink.num_sv = numsv;
-  if (tow == 0) {
-    gps_datalink.tow = gps_tow_from_sys_ticks(sys_time.nb_tick); //tow;
-  } else {
-    gps_datalink.tow = gps_tow_from_sys_ticks(sys_time.nb_tick); //tow;
-  }
+  gps_datalink.tow = tow;
   gps_datalink.fix = GPS_FIX_3D;
 
   // publish new GPS data
   uint32_t now_ts = get_sys_time_usec();
   gps_datalink.last_msg_ticks = sys_time.nb_sec_rem;
   gps_datalink.last_msg_time = sys_time.nb_sec;
-  if (gps_datalink.fix == GPS_FIX_3D) {
-    gps_datalink.last_3dfix_ticks = sys_time.nb_sec_rem;
-    gps_datalink.last_3dfix_time = sys_time.nb_sec;
-  }
+
+  gps_datalink.last_3dfix_ticks = sys_time.nb_sec_rem;
+  gps_datalink.last_3dfix_time = sys_time.nb_sec;
+
   AbiSendMsgGPS(GPS_DATALINK_ID, now_ts, &gps_datalink);
 }
 
diff --git a/sw/airborne/subsystems/gps/gps_datalink.h b/sw/airborne/subsystems/gps/gps_datalink.h
index f71a2ad..93fa1dc 100644
--- a/sw/airborne/subsystems/gps/gps_datalink.h
+++ b/sw/airborne/subsystems/gps/gps_datalink.h
@@ -43,12 +43,11 @@ extern struct GpsState gps_datalink;
 extern void gps_datalink_init(void);
 extern void gps_datalink_register(void);
 
-extern void parse_gps_datalink_small(uint8_t num_sv, uint32_t pos_xyz, uint32_t speed_xyz, int16_t heading);
+extern void parse_gps_datalink_small(int16_t heading, uint32_t pos_xyz, uint32_t speed_xyz, uint32_t tow);
 
 extern void parse_gps_datalink(uint8_t numsv, int32_t ecef_x, int32_t ecef_y, int32_t ecef_z,
                                int32_t lat, int32_t lon, int32_t alt, int32_t hmsl,
                                int32_t ecef_xd, int32_t ecef_yd, int32_t ecef_zd,
                                uint32_t tow, int32_t course);
 
-
 #endif /* GPS_DATALINK_H */
diff --git a/sw/airborne/subsystems/gps/gps_mtk.c b/sw/airborne/subsystems/gps/gps_mtk.c
index 6f6ce51..a0e7dad 100644
--- a/sw/airborne/subsystems/gps/gps_mtk.c
+++ b/sw/airborne/subsystems/gps/gps_mtk.c
@@ -209,9 +209,6 @@ void gps_mtk_read_message(void)
   if (gps_mtk.msg_class == MTK_DIY14_ID) {
     if (gps_mtk.msg_id == MTK_DIY14_NAV_ID) {
       /* get hardware clock ticks */
-      gps_time_sync.t0_ticks      = sys_time.nb_tick;
-      gps_time_sync.t0_tow      = MTK_DIY14_NAV_ITOW(gps_mtk.msg_buf);
-      gps_time_sync.t0_tow_frac = 0;
       gps_mtk.state.lla_pos.lat = MTK_DIY14_NAV_LAT(gps_mtk.msg_buf) * 10;
       gps_mtk.state.lla_pos.lon = MTK_DIY14_NAV_LON(gps_mtk.msg_buf) * 10;
       SetBit(gps_mtk.state.valid_fields, GPS_VALID_POS_LLA_BIT);
diff --git a/sw/airborne/subsystems/navigation/traffic_info.c b/sw/airborne/subsystems/navigation/traffic_info.c
deleted file mode 100644
index 8bdd3b3..0000000
--- a/sw/airborne/subsystems/navigation/traffic_info.c
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Copyright (C) 2005  Pascal Brisset, Antoine Drouin
- *
- * This file is part of paparazzi.
- *
- * paparazzi is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * paparazzi is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with paparazzi; see the file COPYING.  If not, write to
- * the Free Software Foundation, 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-/**
- * @file subsystems/navigation/traffic_info.c
- *
- * Information relative to the other aircrafts.
- *
- */
-
-#include "subsystems/navigation/traffic_info.h"
-
-//#include "subsystems/navigation/common_nav.h"
-#include "generated/airframe.h"     // AC_ID
-#include "math/pprz_geodetic_int.h"
-#include "math/pprz_geodetic_float.h"
-
-uint8_t acs_idx;
-uint8_t the_acs_id[NB_ACS_ID];
-struct ac_info_ the_acs[NB_ACS];
-
-void traffic_info_init(void)
-{
-  the_acs_id[0] = 0;  // ground station
-  the_acs_id[AC_ID] = 1;
-  the_acs[the_acs_id[AC_ID]].ac_id = AC_ID;
-  acs_idx = 2;
-}
-
-struct ac_info_ *get_ac_info(uint8_t _id)
-{
-  return &the_acs[the_acs_id[_id]];
-}
-
-void set_ac_info(uint8_t id, float utm_east, float utm_north, float course, float alt,
-                 float gspeed, float climb, uint32_t itow)
-{
-  if (acs_idx < NB_ACS) {
-    if (id > 0 && the_acs_id[id] == 0) {
-      the_acs_id[id] = acs_idx++;
-      the_acs[the_acs_id[id]].ac_id = id;
-    }
-    the_acs[the_acs_id[id]].east = utm_east;// -  nav_utm_east0;
-    the_acs[the_acs_id[id]].north = utm_north;// - nav_utm_north0;
-    the_acs[the_acs_id[id]].course = course;
-    the_acs[the_acs_id[id]].alt = alt;// +- NAV_MSL0;
-    the_acs[the_acs_id[id]].gspeed = gspeed;
-    the_acs[the_acs_id[id]].climb = climb;
-    the_acs[the_acs_id[id]].itow = itow;
-  }
-}
-
-void set_ac_info_lla(uint8_t id, int32_t lat, int32_t lon, int32_t alt,
-                     int16_t course, uint16_t gspeed, int16_t climb, uint32_t itow)
-{
-  if (acs_idx < NB_ACS) {
-    if (id > 0 && the_acs_id[id] == 0) {
-      the_acs_id[id] = acs_idx++;
-      the_acs[the_acs_id[id]].ac_id = id;
-    }
-
-    struct LlaCoor_i lla_i = {.lat = lat, .lon = lon, .alt = alt};
-    struct LlaCoor_f lla_f;
-    LLA_FLOAT_OF_BFP(lla_f, lla_i);
-
-    struct UtmCoor_f utm_f;
-    utm_of_lla_f(&utm_f, &lla_f);
-
-    the_acs[the_acs_id[id]].east = utm_f.east;
-    the_acs[the_acs_id[id]].north = utm_f.north;
-    the_acs[the_acs_id[id]].alt = utm_f.alt;
-    the_acs[the_acs_id[id]].course = RadOfDeg((float)course / 10.);
-    the_acs[the_acs_id[id]].gspeed = (float)gspeed * 100;
-    the_acs[the_acs_id[id]].climb = (float)climb * 100;
-    the_acs[the_acs_id[id]].itow = itow;
-  }
-}
diff --git a/sw/airborne/subsystems/navigation/traffic_info.h b/sw/airborne/subsystems/navigation/traffic_info.h
deleted file mode 100644
index 3e9d79a..0000000
--- a/sw/airborne/subsystems/navigation/traffic_info.h
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Copyright (C) 2005  Pascal Brisset, Antoine Drouin
- *
- * This file is part of paparazzi.
- *
- * paparazzi is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * paparazzi is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with paparazzi; see the file COPYING.  If not, write to
- * the Free Software Foundation, 59 Temple Place - Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-/**
- * @file subsystems/navigation/traffic_info.h
- *
- * Information relative to the other aircrafts.
- *
- */
-
-#ifndef TI_H
-#define TI_H
-
-#define NB_ACS_ID 256
-#define NB_ACS 24
-
-#include <inttypes.h>
-
-struct ac_info_ {
-  uint8_t ac_id;
-  float east;   ///< m relative to nav_utm_east0
-  float north;  ///< m relative to nav_utm_north0
-  float course; ///< rad (CW)
-  float alt;    ///< m above Mean Sea Level (geoid)
-  float gspeed; ///< m/s
-  float climb;  ///< m/s
-  uint32_t itow;///< ms
-};
-
-extern uint8_t acs_idx;
-extern uint8_t the_acs_id[NB_ACS_ID];
-extern struct ac_info_ the_acs[NB_ACS];
-
-extern void traffic_info_init(void);
-extern struct ac_info_ *get_ac_info(uint8_t id);
-
-/**
- * Set Aircraft info.
- * @param[in] id aircraft id, 0 is reserved for GCS, 1 for this aircraft (id=AC_ID)
- * @param[in] utm_east UTM east in m relative to nav_utm_east0
- * @param[in] utm_north UTM north in m relative to nav_utm_north0
- * @param[in] course Course in rad (CW)
- * @param[in] alt Altitude in m above MSL
- * @param[in] gspeed Ground speed in m/s
- * @param[in] climb Climb rate in m/s
- * @param[in] itow GPS time of week in ms
- */
-extern void set_ac_info(uint8_t id, float utm_east, float utm_north, float course, float alt,
-                        float gspeed, float climb, uint32_t itow);
-
-/**
- * Set Aircraft info.
- * @param[in] id aircraft id, 0 is reserved for GCS, 1 for this aircraft (id=AC_ID)
- * @param[in] lat Latitude in 1e7deg
- * @param[in] lon Longitude in 1e7deg
- * @param[in] alt Altitude in mm above MSL
- * @param[in] course Course in decideg (CW)
- * @param[in] gspeed Ground speed in cm/s
- * @param[in] climb Climb rate in cm/s
- * @param[in] itow GPS time of week in ms
- */
-extern void set_ac_info_lla(uint8_t id, int32_t lat, int32_t lon, int32_t alt,
-                            int16_t course, uint16_t gspeed, int16_t climb, uint32_t itow);
-
-#endif
